## API Report File for "decentraland-ecs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public (undocumented)
export enum ActionButton {
    // (undocumented)
    POINTER = "POINTER",
    // (undocumented)
    PRIMARY = "PRIMARY",
    // (undocumented)
    SECONDARY = "SECONDARY"
}

// @public
export class Angle {
    constructor(radians: number);
    static BetweenTwoPoints(a: Vector2, b: Vector2): Angle;
    degrees(): number;
    static FromDegrees(degrees: number): Angle;
    static FromRadians(radians: number): Angle;
    radians(): number;
    }

// @public (undocumented)
export type AnimationParams = {
    looping?: boolean;
    speed?: number;
    weight?: number;
};

// @public (undocumented)
export class AnimationState extends ObservableComponent {
    constructor(clip: string, params?: AnimationParams);
    readonly clip: string;
    looping: boolean;
    pause(): void;
    play(): void;
    playing: boolean;
    reset(): void;
    setParams(params: AnimationParams): this;
    shouldReset: boolean;
    speed: number;
    stop(): void;
    // (undocumented)
    toJSON(): any;
    weight: number;
}

// @public (undocumented)
export class Animator extends Shape {
    addClip(clip: AnimationState): this;
    getClip(clipName: string): AnimationState;
    }

// @public
export class Arc2 {
    constructor(
    startPoint: Vector2, 
    midPoint: Vector2, 
    endPoint: Vector2);
    angle: Angle;
    centerPoint: Vector2;
    endPoint: Vector2;
    midPoint: Vector2;
    orientation: Orientation;
    radius: number;
    startAngle: Angle;
    startPoint: Vector2;
}

// @public (undocumented)
export class AudioClip extends ObservableComponent {
    constructor(url: string);
    loop: boolean;
    // (undocumented)
    readonly url: string;
    volume: number;
}

// @public (undocumented)
export class AudioSource extends ObservableComponent {
    constructor(audioClip: AudioClip);
    // (undocumented)
    readonly audioClip: AudioClip;
    // (undocumented)
    readonly audioClipId: string;
    loop: boolean;
    pitch: number;
    playing: boolean;
    playOnce(): this;
    volume: number;
}

// @public (undocumented)
export type AvatarForRenderer = {
    bodyShape: WearableId;
    skinColor: ReadOnlyColor4;
    hairColor: ReadOnlyColor4;
    eyeColor: ReadOnlyColor4;
    wearables: WearableId[];
};

// @public (undocumented)
export class AvatarShape extends ObservableComponent {
    // (undocumented)
    bodyShape: WearableId;
    // (undocumented)
    static Dummy(): AvatarShape;
    // (undocumented)
    eyeColor: ReadOnlyColor4;
    // (undocumented)
    hairColor: ReadOnlyColor4;
    // (undocumented)
    id: string;
    // (undocumented)
    name: string;
    // (undocumented)
    skinColor: ReadOnlyColor4;
    // (undocumented)
    useDummyModel: boolean;
    // (undocumented)
    wearables: WearableId[];
}

// @public
export class Axis {
    static X: Vector3;
    static Y: Vector3;
    static Z: Vector3;
}

// @public (undocumented)
export interface BasicAvatarInfo {
    // (undocumented)
    name: string;
    // (undocumented)
    userId: string;
}

// @public (undocumented)
export class BasicMaterial extends ObservableComponent {
    alphaTest: number;
    texture?: Texture;
}

// @public
export class BezierCurve {
    static Interpolate(t: number, x1: number, y1: number, x2: number, y2: number): number;
}

// @public
export class Billboard extends ObservableComponent {
    constructor(x?: boolean, y?: boolean, z?: boolean);
    // (undocumented)
    x: boolean;
    // (undocumented)
    y: boolean;
    // (undocumented)
    z: boolean;
}

// @public (undocumented)
export type BodyShapeRespresentation = {
    bodyShapes: string[];
    mainFile: string;
    contents: FileAndHash[];
};

// @public (undocumented)
export class BoxShape extends Shape {
}

// @public (undocumented)
export class Camera {
    constructor();
    readonly feetPosition: Vector3;
    // (undocumented)
    static readonly instance: Camera;
    readonly playerHeight: number;
    readonly position: Vector3;
    readonly rotation: Quaternion;
    readonly worldPosition: Vector3;
}

// @public (undocumented)
export class CircleShape extends Shape {
    // (undocumented)
    arc?: number;
    // (undocumented)
    segments?: number;
}

// @public
export class Color3 {
    constructor(
    r?: number, 
    g?: number, 
    b?: number);
    add(otherColor: Color3): Color3;
    addToRef(otherColor: Color3, result: Color3): Color3;
    asArray(): number[];
    b: number;
    static Black(): Color3;
    static Blue(): Color3;
    clampToRef(min: number | undefined, max: number | undefined, result: Color3): Color3;
    clone(): Color3;
    copyFrom(source: Color3): Color3;
    copyFromFloats(r: number, g: number, b: number): Color3;
    equals(otherColor: Color3): boolean;
    equalsFloats(r: number, g: number, b: number): boolean;
    static FromArray(array: ArrayLike<number>, offset?: number): Color3;
    static FromHexString(hex: string): Color3;
    static FromInts(r: number, g: number, b: number): Color3;
    g: number;
    getClassName(): string;
    getHashCode(): number;
    static Gray(): Color3;
    static Green(): Color3;
    static Lerp(start: Color3, end: Color3, amount: number): Color3;
    static LerpToRef(left: Color3, right: Color3, amount: number, result: Color3): void;
    static Magenta(): Color3;
    multiply(otherColor: Color3): Color3;
    multiplyToRef(otherColor: Color3, result: Color3): Color3;
    static Purple(): Color3;
    r: number;
    static Random(): Color3;
    static Red(): Color3;
    scale(scale: number): Color3;
    scaleAndAddToRef(scale: number, result: Color3): Color3;
    scaleToRef(scale: number, result: Color3): Color3;
    set(r: number, g: number, b: number): Color3;
    subtract(otherColor: Color3): Color3;
    subtractToRef(otherColor: Color3, result: Color3): Color3;
    static Teal(): Color3;
    toArray(array: FloatArray, index?: number): Color3;
    toColor4(alpha?: number): Color4;
    toGammaSpace(): Color3;
    toGammaSpaceToRef(convertedColor: Color3): Color3;
    toHexString(): string;
    toJSON(): {
        r: number;
        g: number;
        b: number;
    };
    toLinearSpace(): Color3;
    toLinearSpaceToRef(convertedColor: Color3): Color3;
    toLuminance(): number;
    toString(): string;
    static White(): Color3;
    static Yellow(): Color3;
}

// @public
export class Color4 {
    constructor(
    r?: number, 
    g?: number, 
    b?: number, 
    a?: number);
    a: number;
    add(right: Color4): Color4;
    addInPlace(right: Color4): Color4;
    asArray(): number[];
    b: number;
    static Black(): Color4;
    static Blue(): Color4;
    static CheckColors4(colors: number[], count: number): number[];
    clampToRef(min: number | undefined, max: number | undefined, result: Color4): Color4;
    static Clear(): Color4;
    clone(): Color4;
    copyFrom(source: Color4): Color4;
    copyFromFloats(r: number, g: number, b: number, a: number): Color4;
    static FromArray(array: ArrayLike<number>, offset?: number): Color4;
    static FromColor3(color3: Color3, alpha?: number): Color4;
    static FromHexString(hex: string): Color4;
    static FromInts(r: number, g: number, b: number, a: number): Color4;
    g: number;
    getClassName(): string;
    getHashCode(): number;
    static Gray(): Color4;
    static Green(): Color4;
    static Lerp(left: Color4, right: Color4, amount: number): Color4;
    static LerpToRef(left: Color4, right: Color4, amount: number, result: Color4): void;
    static Magenta(): Color4;
    multiply(color: Color4): Color4;
    multiplyToRef(color: Color4, result: Color4): Color4;
    static Purple(): Color4;
    r: number;
    static Red(): Color4;
    scale(scale: number): Color4;
    scaleAndAddToRef(scale: number, result: Color4): Color4;
    scaleToRef(scale: number, result: Color4): Color4;
    set(r: number, g: number, b: number, a: number): Color4;
    subtract(right: Color4): Color4;
    subtractToRef(right: Color4, result: Color4): Color4;
    static Teal(): Color4;
    toArray(array: number[], index?: number): Color4;
    toGammaSpace(): Color4;
    toGammaSpaceToRef(convertedColor: Color4): Color4;
    toHexString(): string;
    toLinearSpace(): Color4;
    toLinearSpaceToRef(convertedColor: Color4): Color4;
    toString(): string;
    static White(): Color4;
    static Yellow(): Color4;
}

// @public (undocumented)
export function Component(componentName: string, classId?: number): <TFunction extends ComponentConstructor<any>>(target: TFunction) => void | TFunction;

// @public (undocumented)
export class ComponentAdded {
    constructor(entity: IEntity, componentName: string, classId: number | null);
    // (undocumented)
    classId: number | null;
    // (undocumented)
    componentName: string;
    // (undocumented)
    entity: IEntity;
}

// @public (undocumented)
export interface ComponentConstructor<T extends ComponentLike> {
    // (undocumented)
    new (...args: any[]): T;
    // (undocumented)
    isComponent?: boolean;
    // (undocumented)
    originalClassName?: string;
}

// @public (undocumented)
export interface ComponentLike {
}

// @public (undocumented)
export class ComponentRemoved {
    constructor(entity: IEntity, componentName: string, component: ComponentLike);
    // (undocumented)
    component: ComponentLike;
    // (undocumented)
    componentName: string;
    // (undocumented)
    entity: IEntity;
}

// @public (undocumented)
export class ConeShape extends Shape {
    arc: number;
    openEnded: boolean;
    radius: number | null;
    radiusBottom: number;
    radiusTop: number;
    segmentsHeight: number;
    segmentsRadial: number;
}

// @public
export class Curve3 {
    constructor(points: Vector3[]);
    continue(curve: Curve3): Curve3;
    static CreateCatmullRomSpline(points: Vector3[], nbPoints: number, closed?: boolean): Curve3;
    static CreateCubicBezier(v0: Vector3, v1: Vector3, v2: Vector3, v3: Vector3, nbPoints: number): Curve3;
    static CreateHermiteSpline(p1: Vector3, t1: Vector3, p2: Vector3, t2: Vector3, nbPoints: number): Curve3;
    static CreateQuadraticBezier(v0: Vector3, v1: Vector3, v2: Vector3, nbPoints: number): Curve3;
    // (undocumented)
    getPoints(): Vector3[];
    // (undocumented)
    length(): number;
    }

// @public (undocumented)
export class CylinderShape extends Shape {
    arc: number;
    openEnded: boolean;
    radius: number | null;
    radiusBottom: number;
    radiusTop: number;
    segmentsHeight: number;
    segmentsRadial: number;
}

// @public (undocumented)
export type DecentralandInterface = {
    DEBUG: boolean;
    updateEntity?: never;
    log(...a: any[]): void;
    error(message: string, data?: any): void;
    onUpdate(cb: (deltaTime: number) => void): void;
    onStart(cb: Function): void;
    addEntity(entityId: string): void;
    removeEntity(entityId: string): void;
    updateEntityComponent(entityId: string, componentName: string, classId: number, json: string): void;
    attachEntityComponent(entityId: string, componentName: string, componentId: string): void;
    removeEntityComponent(entityId: string, componentName: string): void;
    setParent(entityId: string, parentId: string): void;
    query(queryId: string, payload: any): void;
    componentCreated(componentId: string, componentName: string, classId: number): void;
    componentDisposed(componentId: string): void;
    componentUpdated(componentId: string, json: string): void;
    onEvent(cb: (event: EngineEvent) => void): void;
    subscribe(eventName: string): void;
    unsubscribe(eventName: string): void;
    loadModule(moduleName: string): PromiseLike<ModuleDescriptor>;
    callRpc(rpcHandle: string, methodName: string, args: ArrayLike<any>): PromiseLike<any>;
};

// @public
export const DEG2RAD: number;

// @public (undocumented)
export function DisposableComponent(componentName: string, classId: number): <TFunction extends DisposableComponentConstructor<any>>(target: TFunction) => void | TFunction;

// @public (undocumented)
export interface DisposableComponentConstructor<T extends DisposableComponentLike> {
    // (undocumented)
    new (...args: any[]): T;
    // (undocumented)
    isComponent?: boolean;
    // (undocumented)
    isDisposableComponent?: true;
    // (undocumented)
    originalClassName?: string;
}

// @public (undocumented)
export class DisposableComponentCreated {
    constructor(componentId: string, componentName: string, classId: number);
    // (undocumented)
    classId: number;
    // (undocumented)
    componentId: string;
    // (undocumented)
    componentName: string;
}

// @public (undocumented)
export interface DisposableComponentLike extends ComponentLike {
    // (undocumented)
    onDispose?(): void;
}

// @public (undocumented)
export class DisposableComponentRemoved {
    constructor(componentId: string);
    // (undocumented)
    componentId: string;
}

// @public (undocumented)
export class DisposableComponentUpdated {
    constructor(componentId: string, component: DisposableComponentLike);
    // (undocumented)
    component: DisposableComponentLike;
    // (undocumented)
    componentId: string;
}

// @public (undocumented)
export type double = number;

// @public (undocumented)
export class Engine implements IEngine {
    constructor(rootEntity: IEntity);
    // (undocumented)
    addEntity(entity: IEntity): IEntity;
    // (undocumented)
    addSystem(system: ISystem, priority?: number): ISystem;
    // (undocumented)
    readonly disposableComponents: Readonly<Record<string, DisposableComponentLike>>;
    // (undocumented)
    disposeComponent(component: DisposableComponentLike): boolean;
    // (undocumented)
    readonly entities: Readonly<Record<string, IEntity>>;
    // (undocumented)
    readonly eventManager: EventManager;
    // Warning: (ae-forgotten-export) The symbol "ComponentGroup" needs to be exported by the entry point index.d.ts
    // 
    // (undocumented)
    getComponentGroup(...requires: ComponentConstructor<any>[]): ComponentGroup;
    // (undocumented)
    getEntitiesWithComponent(component: string): Record<string, any>;
    // (undocumented)
    getEntitiesWithComponent(component: ComponentConstructor<any>): Record<string, IEntity>;
    // (undocumented)
    registerComponent(component: DisposableComponentLike): void;
    // (undocumented)
    removeComponentGroup(componentGroup: ComponentGroup): boolean;
    // (undocumented)
    removeEntity(entity: IEntity): boolean;
    // (undocumented)
    removeSystem(system: ISystem): boolean;
    // (undocumented)
    readonly rootEntity: IEntity;
    // (undocumented)
    update(dt: number): this;
    // (undocumented)
    updateComponent(component: DisposableComponentLike): void;
}

// @public (undocumented)
export const engine: Engine;

// @public (undocumented)
export type EngineEvent<T extends IEventNames = IEventNames, V = IEvents[T]> = {
    type: T;
    data: V;
};

// @public (undocumented)
export class Entity implements IEntity {
    constructor(name?: string | undefined);
    addComponent<T extends object>(component: T): T;
    addComponentOrReplace<T extends object>(component: T): T;
    // (undocumented)
    alive: boolean;
    // (undocumented)
    children: Record<string, IEntity>;
    // (undocumented)
    readonly components: Record<string, any>;
    // (undocumented)
    eventManager: EventManager | null;
    // (undocumented)
    getComponent<T>(component: ComponentConstructor<T>): T;
    getComponent<T = any>(component: string): T;
    getComponentOrCreate<T>(component: ComponentConstructor<T> & {
        new (): T;
    }): T;
    getComponentOrNull<T = any>(component: string): T | null;
    // (undocumented)
    getComponentOrNull<T>(component: ComponentConstructor<T>): T | null;
    getParent(): IEntity | null;
    // (undocumented)
    hasComponent<T>(component: ComponentConstructor<T>): boolean;
    // (undocumented)
    hasComponent<T extends object>(component: T): boolean;
    hasComponent<T = any>(component: string): boolean;
    isAddedToEngine(): boolean;
    // (undocumented)
    name?: string | undefined;
    // (undocumented)
    removeComponent(component: ComponentConstructor<any>, triggerRemovedEvent?: boolean): void;
    // (undocumented)
    removeComponent<T extends object>(component: T, triggerRemovedEvent?: boolean): void;
    removeComponent(component: string, triggerRemovedEvent?: boolean): void;
    setParent(_parent: IEntity | null): IEntity;
    // (undocumented)
    readonly uuid: string;
}

// @public
export const Epsilon = 0.000001;

// @public
export function error(error: string | Error, data?: any): void;

// @public (undocumented)
export function EventConstructor(): ClassDecorator;

// @public (undocumented)
export class EventManager {
    // (undocumented)
    addListener<T, X>(eventClass: IEventConstructor<T>, listener: X, listenerFunction: (this: X, event: T) => void): this;
    // (undocumented)
    fireEvent<T extends object>(event: T): this;
    // (undocumented)
    removeListener<X>(listener: X, eventClass: IEventConstructor<any>): boolean;
}

// @public
export function executeTask<T>(task: () => Promise<T>): TaskResult<T>;

// @public (undocumented)
export type FileAndHash = {
    file: string;
    hash: string;
};

// @public (undocumented)
export type float = number;

// @public (undocumented)
export type FloatArray = number[];

// @beta
export class Frustum {
    static GetBottomPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
    static GetFarPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
    static GetLeftPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
    static GetNearPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
    static GetPlanes(transform: Matrix): Plane[];
    static GetPlanesToRef(transform: Matrix, frustumPlanes: Plane[]): void;
    static GetRightPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
    static GetTopPlaneToRef(transform: Matrix, frustumPlane: Plane): void;
}

// @public (undocumented)
export function getComponentClassId<T extends Record<any, any> = any>(component: T | ComponentConstructor<T>): number | null;

// @public (undocumented)
export function getComponentId<T extends DisposableComponentLike>(component: T): string;

// @public (undocumented)
export function getComponentName<T extends Record<any, any> = any>(component: T | ComponentConstructor<T>): string;

// @beta
export enum Gizmo {
    // (undocumented)
    MOVE = "MOVE",
    // (undocumented)
    NONE = "NONE",
    // (undocumented)
    ROTATE = "ROTATE",
    // (undocumented)
    SCALE = "SCALE"
}

// @public (undocumented)
export type GizmoDragEndEvent = {
    type: 'gizmoDragEnded';
    transform: {
        position: ReadOnlyVector3;
        rotation: ReadOnlyQuaternion;
        scale: ReadOnlyVector3;
    };
    entityId: string;
};

// @beta
export class Gizmos extends ObservableComponent {
    cycle: boolean;
    localReference: boolean;
    position: boolean;
    rotation: boolean;
    scale: boolean;
    selectedGizmo?: Gizmo;
}

// @public (undocumented)
export type GizmoSelectedEvent = {
    type: 'gizmoSelected';
    gizmoType: 'MOVE' | 'ROTATE' | 'SCALE' | 'NONE';
    entityId: string;
};

// @public (undocumented)
export type GlobalInputEventResult = InputEventResult & {
    type: InputEventType;
};

// @public (undocumented)
export class GlobalPointerDown extends PointerEventComponent {
}

// @public (undocumented)
export class GlobalPointerUp extends PointerEventComponent {
}

// @public (undocumented)
export class GLTFShape extends Shape {
    constructor(src: string);
    // (undocumented)
    readonly src: string;
}

// @public (undocumented)
export interface HitEntityInfo {
    // (undocumented)
    entityId: string;
    // (undocumented)
    isValid: boolean;
    // (undocumented)
    meshName: string;
}

// @public (undocumented)
export interface IEngine {
    // (undocumented)
    addEntity(entity: IEntity): void;
    // (undocumented)
    addSystem(system: ISystem, priority: number): void;
    // (undocumented)
    readonly entities: Readonly<Record<string, IEntity>>;
    // (undocumented)
    removeEntity(entity: IEntity): void;
    // (undocumented)
    removeSystem(system: ISystem): void;
    // (undocumented)
    rootEntity: IEntity;
}

// @public (undocumented)
export interface IEntity {
    addComponent<T extends object>(component: T): void;
    // (undocumented)
    addComponentOrReplace<T extends object>(component: T): void;
    // (undocumented)
    alive: boolean;
    // (undocumented)
    children: Record<string, IEntity>;
    // (undocumented)
    readonly components: Record<string, any>;
    // (undocumented)
    eventManager: EventManager | null;
    // (undocumented)
    getComponent<T = any>(component: string): T;
    // (undocumented)
    getComponent<T>(component: ComponentConstructor<T>): T;
    // (undocumented)
    getComponent<T>(component: ComponentConstructor<T> | string): T;
    // (undocumented)
    getComponentOrCreate<T>(component: ComponentConstructor<T> & {
        new (): T;
    }): T;
    // (undocumented)
    getComponentOrNull<T>(component: ComponentConstructor<T>): T | null;
    getComponentOrNull<T = any>(component: string): T | null;
    // (undocumented)
    getComponentOrNull<T>(component: ComponentConstructor<T> | string): T | null;
    // (undocumented)
    getParent(): IEntity | null;
    // (undocumented)
    hasComponent<T>(component: ComponentConstructor<T> | string): boolean;
    // (undocumented)
    hasComponent<T extends object>(component: T): boolean;
    // (undocumented)
    hasComponent<T = any>(component: string): boolean;
    // (undocumented)
    hasComponent<T>(component: ComponentConstructor<T>): boolean;
    // (undocumented)
    isAddedToEngine(): boolean;
    // (undocumented)
    removeComponent(component: ComponentConstructor<any>, triggerRemovedEvent?: boolean): void;
    // (undocumented)
    removeComponent(component: object | string | Function, triggerRemovedEvent: any): void;
    // (undocumented)
    removeComponent(component: string, triggerRemovedEvent?: boolean): void;
    // (undocumented)
    removeComponent<T extends object>(component: T, triggerRemovedEvent?: boolean): void;
    // (undocumented)
    setParent(e: IEntity): void;
    // (undocumented)
    readonly uuid: string;
}

// @public (undocumented)
export interface IEventConstructor<T> {
    // (undocumented)
    new (...args: any[]): T;
}

// @public (undocumented)
export type IEventNames = keyof IEvents;

// @public (undocumented)
export interface IEvents {
    builderSceneStart: {};
    builderSceneUnloaded: {};
    chatMessage: {
        id: string;
        sender: string;
        message: string;
        isCommand: boolean;
    };
    comms: {
        sender: string;
        message: string;
    };
    entitiesOutOfBoundaries: {
        entities: string[];
    };
    entityBackInScene: {
        entityId: string;
    };
    entityOutOfScene: {
        entityId: string;
    };
    gizmoEvent: GizmoDragEndEvent | GizmoSelectedEvent;
    // (undocumented)
    limitsExceeded: {
        given: Record<string, number>;
        limit: Record<string, number>;
    };
    // (undocumented)
    metricsUpdate: {
        given: Record<string, number>;
        limit: Record<string, number>;
    };
    onAnimationEnd: {
        clipName: string;
    };
    onBlur: {
        entityId: string;
        pointerId: number;
    };
    onChange: {
        value?: any;
        pointerId?: number;
    };
    onClick: {
        entityId: string;
    };
    onEnter: {};
    onFocus: {
        entityId: string;
        pointerId: number;
    };
    // (undocumented)
    onTextSubmit: {
        text: string;
    };
    pointerDown: InputEventResult;
    pointerEvent: GlobalInputEventResult;
    pointerUp: InputEventResult;
    positionChanged: {
        position: ReadOnlyVector3;
        cameraPosition: ReadOnlyVector3;
        playerHeight: number;
    };
    raycastResponse: RaycastResponse<any>;
    rotationChanged: {
        rotation: ReadOnlyVector3;
        quaternion: ReadOnlyQuaternion;
    };
    sceneStart: {};
    // (undocumented)
    uuidEvent: {
        uuid: string;
        payload: any;
    };
}

// @public (undocumented)
export class Input {
    // (undocumented)
    static ensureInstance(): any;
    // (undocumented)
    handlePointerEvent(data: GlobalInputEventResult): void;
    // (undocumented)
    static readonly instance: Input;
    isButtonPressed(buttonId: ActionButton): {
        BUTTON_DOWN: boolean;
    };
    // Warning: (ae-forgotten-export) The symbol "Subscription" needs to be exported by the entry point index.d.ts
    subscribe(eventName: InputEventKind, buttonId: ActionButton, useRaycast: boolean, fn: (e: LocalActionButtonEvent) => void): () => false | Subscription[];
    unsubscribe(eventName: InputEventKind, buttonId: ActionButton, fn: (e: LocalActionButtonEvent) => void): false | Subscription[];
}

// @public (undocumented)
export type InputEventKind = 'BUTTON_DOWN' | 'BUTTON_UP';

// @public (undocumented)
export type InputEventResult = {
    origin: ReadOnlyVector3;
    direction: ReadOnlyVector3;
    buttonId: number;
    hit?: {
        length: number;
        hitPoint: ReadOnlyVector3;
        meshName: string;
        normal: ReadOnlyVector3;
        worldNormal: ReadOnlyVector3;
        entityId: string;
    };
};

// @public (undocumented)
export enum InputEventType {
    // (undocumented)
    DOWN = 0,
    // (undocumented)
    UP = 1
}

// @public (undocumented)
export type InputState = Record<ActionButton, {
    BUTTON_DOWN: boolean;
}>;

// @public (undocumented)
export interface IPhysicsCast {
    // (undocumented)
    hitAll: (ray: Ray, hitCallback: (event: RaycastHitEntities) => void) => void;
    // (undocumented)
    hitFirst: (ray: Ray, hitCallback: (event: RaycastHitEntity) => void) => void;
}

// @public (undocumented)
export function isDisposableComponent(component: ComponentLike): boolean;

// @public
export interface ISize {
    height: number;
    width: number;
}

// @public (undocumented)
export interface ISystem {
    // (undocumented)
    activate?(engine: IEngine): void;
    // (undocumented)
    active?: boolean;
    // (undocumented)
    deactivate?(): void;
    // (undocumented)
    onAddEntity?(entity: IEntity): void;
    // (undocumented)
    onRemoveEntity?(entity: IEntity): void;
    // (undocumented)
    update?(dt: number): void;
}

// @public (undocumented)
export type LocalActionButtonEvent = GlobalInputEventResult & {
    origin: Vector3;
    direction: Vector3;
    button: ActionButton;
    hit?: GlobalInputEventResult['hit'] & {
        hitPoint: Vector3;
        normal: Vector3;
        worldNormal: Vector3;
    };
};

// @public
export function log(...args: any[]): void;

// @public (undocumented)
export class Material extends ObservableComponent {
    albedoColor?: Color4 | Color3;
    albedoTexture?: Texture;
    alphaTest?: number;
    alphaTexture?: Texture;
    ambientColor?: Color3;
    bumpTexture?: Texture;
    directIntensity?: number;
    disableLighting?: boolean;
    emissiveColor?: Color3;
    emissiveIntensity?: number;
    emissiveTexture?: Texture;
    environmentIntensity?: number;
    metallic?: number;
    microSurface?: number;
    reflectionColor?: Color3;
    reflectivityColor?: Color3;
    refractionTexture?: Texture;
    roughness?: number;
    specularIntensity?: number;
    transparencyMode: TransparencyMode;
}

// @public
export class Matrix {
    constructor();
    add(other: Matrix): Matrix;
    addAtIndex(index: number, value: number): Matrix;
    addToRef(other: Matrix, result: Matrix): Matrix;
    addToSelf(other: Matrix): Matrix;
    asArray(): Readonly<FloatArray>;
    clone(): Matrix;
    static Compose(scale: Vector3, rotation: Quaternion, translation: Vector3): Matrix;
    static ComposeToRef(scale: Vector3, rotation: Quaternion, translation: Vector3, result: Matrix): void;
    copyFrom(other: Readonly<Matrix>): Matrix;
    copyToArray(array: FloatArray, offset?: number): Matrix;
    decompose(scale?: Vector3, rotation?: Quaternion, translation?: Vector3): boolean;
    static DecomposeLerp(startValue: Matrix, endValue: Matrix, gradient: number): Matrix;
    static DecomposeLerpToRef(startValue: Matrix, endValue: Matrix, gradient: number, result: Matrix): void;
    determinant(): number;
    equals(value: Matrix): boolean;
    static FromArray(array: ArrayLike<number>, offset?: number): Matrix;
    static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Matrix): void;
    static FromFloatArrayToRefScaled(array: FloatArray, offset: number, scale: number, result: Matrix): void;
    static FromQuaternionToRef(quat: Quaternion, result: Matrix): void;
    static FromValues(initialM11: number, initialM12: number, initialM13: number, initialM14: number, initialM21: number, initialM22: number, initialM23: number, initialM24: number, initialM31: number, initialM32: number, initialM33: number, initialM34: number, initialM41: number, initialM42: number, initialM43: number, initialM44: number): Matrix;
    static FromValuesToRef(initialM11: number, initialM12: number, initialM13: number, initialM14: number, initialM21: number, initialM22: number, initialM23: number, initialM24: number, initialM31: number, initialM32: number, initialM33: number, initialM34: number, initialM41: number, initialM42: number, initialM43: number, initialM44: number, result: Matrix): void;
    static FromXYZAxesToRef(xaxis: Vector3, yaxis: Vector3, zaxis: Vector3, result: Matrix): void;
    static GetAsMatrix2x2(matrix: Matrix): FloatArray;
    static GetAsMatrix3x3(matrix: Matrix): FloatArray;
    getClassName(): string;
    getHashCode(): number;
    getRotationMatrix(): Matrix;
    getRotationMatrixToRef(result: Matrix): Matrix;
    getRow(index: number): Nullable<Vector4>;
    getTranslation(): Vector3;
    getTranslationToRef(result: Vector3): Matrix;
    static Identity(): Matrix;
    static readonly IdentityReadOnly: Readonly<Matrix>;
    static IdentityToRef(result: Matrix): void;
    static Invert(source: Matrix): Matrix;
    invert(): Matrix;
    invertToRef(other: Matrix): Matrix;
    isIdentity(): boolean;
    isIdentityAs3x2(): boolean;
    static Lerp(startValue: Matrix, endValue: Matrix, gradient: number): Matrix;
    static LerpToRef(startValue: Matrix, endValue: Matrix, gradient: number, result: Matrix): void;
    static LookAtLH(eye: Vector3, target: Vector3, up: Vector3): Matrix;
    static LookAtLHToRef(eye: Vector3, target: Vector3, up: Vector3, result: Matrix): void;
    static LookAtRH(eye: Vector3, target: Vector3, up: Vector3): Matrix;
    static LookAtRHToRef(eye: Vector3, target: Vector3, up: Vector3, result: Matrix): void;
    readonly m: Readonly<FloatArray>;
    multiply(other: Readonly<Matrix>): Matrix;
    multiplyAtIndex(index: number, value: number): Matrix;
    multiplyToArray(other: Readonly<Matrix>, result: FloatArray, offset: number): Matrix;
    multiplyToRef(other: Readonly<Matrix>, result: Matrix): Matrix;
    static OrthoLH(width: number, height: number, znear: number, zfar: number): Matrix;
    static OrthoLHToRef(width: number, height: number, znear: number, zfar: number, result: Matrix): void;
    static OrthoOffCenterLH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix;
    static OrthoOffCenterLHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix): void;
    static OrthoOffCenterRH(left: number, right: number, bottom: number, top: number, znear: number, zfar: number): Matrix;
    static OrthoOffCenterRHToRef(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, result: Matrix): void;
    static PerspectiveFovLH(fov: number, aspect: number, znear: number, zfar: number): Matrix;
    static PerspectiveFovLHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed?: boolean): void;
    static PerspectiveFovRH(fov: number, aspect: number, znear: number, zfar: number): Matrix;
    static PerspectiveFovRHToRef(fov: number, aspect: number, znear: number, zfar: number, result: Matrix, isVerticalFovFixed?: boolean): void;
    static PerspectiveFovWebVRToRef(fov: {
        upDegrees: number;
        downDegrees: number;
        leftDegrees: number;
        rightDegrees: number;
    }, znear: number, zfar: number, result: Matrix, rightHanded?: boolean): void;
    static PerspectiveLH(width: number, height: number, znear: number, zfar: number): Matrix;
    static Reflection(plane: Plane): Matrix;
    static ReflectionToRef(plane: Plane, result: Matrix): void;
    removeRotationAndScaling(): Matrix;
    reset(): Matrix;
    static RotationAxis(axis: Vector3, angle: number): Matrix;
    static RotationAxisToRef(axis: Vector3, angle: number, result: Matrix): void;
    static RotationX(angle: number): Matrix;
    static RotationXToRef(angle: number, result: Matrix): void;
    static RotationY(angle: number): Matrix;
    static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Matrix;
    static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Matrix): void;
    static RotationYToRef(angle: number, result: Matrix): void;
    static RotationZ(angle: number): Matrix;
    static RotationZToRef(angle: number, result: Matrix): void;
    scale(scale: number): Matrix;
    scaleAndAddToRef(scale: number, result: Matrix): Matrix;
    scaleToRef(scale: number, result: Matrix): Matrix;
    static Scaling(x: number, y: number, z: number): Matrix;
    static ScalingToRef(x: number, y: number, z: number, result: Matrix): void;
    setRow(index: number, row: Vector4): Matrix;
    setRowFromFloats(index: number, x: number, y: number, z: number, w: number): Matrix;
    setTranslation(vector3: Vector3): Matrix;
    setTranslationFromFloats(x: number, y: number, z: number): Matrix;
    toArray(): Readonly<FloatArray>;
    toggleModelMatrixHandInPlace(): void;
    toggleProjectionMatrixHandInPlace(): void;
    toNormalMatrix(ref: Matrix): void;
    static Translation(x: number, y: number, z: number): Matrix;
    static TranslationToRef(x: number, y: number, z: number, result: Matrix): void;
    static Transpose(matrix: Matrix): Matrix;
    transpose(): Matrix;
    static TransposeToRef(matrix: Matrix, result: Matrix): void;
    transposeToRef(result: Matrix): Matrix;
    updateFlag: number;
    static Zero(): Matrix;
}

// @public (undocumented)
export class MessageBus {
    constructor();
    // (undocumented)
    emit(message: string, payload: Record<any, any>): void;
    // (undocumented)
    on(message: string, callback: (value: any, sender: string) => void): Observer<IEvents['comms']>;
}

// @public (undocumented)
export type MethodDescriptor = {
    name: string;
};

// @public (undocumented)
export type ModuleDescriptor = {
    rpcHandle: string;
    methods: MethodDescriptor[];
};

// @public
export class MultiObserver<T> {
    dispose(): void;
    static Watch<T>(observables: Observable<T>[], callback: (eventData: T, eventState: ObserverEventState) => void, mask?: number, scope?: any): MultiObserver<T>;
}

// @beta
export function newId(type: string): string;

// @public (undocumented)
export class NFTShape extends Shape {
    constructor(src: string, color?: Color3);
    // (undocumented)
    color: Color3;
    // (undocumented)
    readonly src: string;
}

// @public (undocumented)
export type Nullable<T> = T | null;

// @public (undocumented)
export class OBJShape extends Shape {
    constructor(src: string);
    // (undocumented)
    readonly src: string;
}

// @public
export class Observable<T> {
    constructor(onObserverAdded?: (observer: Observer<T>) => void);
    add(callback: (eventData: T, eventState: ObserverEventState) => void, mask?: number, insertFirst?: boolean, scope?: any, unregisterOnFirstCall?: boolean): null | Observer<T>;
    addOnce(callback: (eventData: T, eventState: ObserverEventState) => void): null | Observer<T>;
    clear(): void;
    clone(): Observable<T>;
    hasObservers(): boolean;
    hasSpecificMask(mask?: number): boolean;
    notifyObserver(observer: Observer<T>, eventData: T, mask?: number): void;
    notifyObservers(eventData: T, mask?: number, target?: any, currentTarget?: any): boolean;
    notifyObserversWithPromise(eventData: T, mask?: number, target?: any, currentTarget?: any): Promise<T>;
    remove(observer: null | Observer<T>): boolean;
    removeCallback(callback: (eventData: T, eventState: ObserverEventState) => void, scope?: any): boolean;
}

// @public (undocumented)
export class ObservableComponent {
    // (undocumented)
    static component(target: ObservableComponent, propertyKey: string): void;
    // (undocumented)
    data: any;
    // (undocumented)
    dirty: boolean;
    // (undocumented)
    static field(target: ObservableComponent, propertyKey: string): void;
    // (undocumented)
    onChange(fn: ObservableComponentSubscription): this;
    // (undocumented)
    static readonly(target: ObservableComponent, propertyKey: string): void;
    // (undocumented)
    toJSON(): any;
    // (undocumented)
    static uiValue(target: ObservableComponent, propertyKey: string): void;
}

// @public (undocumented)
export type ObservableComponentSubscription = (key: string, newVal: any, oldVal: any) => void;

// @public
export class Observer<T> {
    constructor(
    callback: (eventData: T, eventState: ObserverEventState) => void, 
    mask: number, 
    scope?: any);
    callback: (eventData: T, eventState: ObserverEventState) => void;
    mask: number;
    scope: any;
    unregisterOnNextCall: boolean;
    _willBeUnregistered: boolean;
}

// @public
export class ObserverEventState {
    constructor(mask: number, skipNextObservers?: boolean, target?: any, currentTarget?: any);
    currentTarget?: any;
    initalize(mask: number, skipNextObservers?: boolean, target?: any, currentTarget?: any): ObserverEventState;
    lastReturnValue?: any;
    mask: number;
    skipNextObservers: boolean;
    target?: any;
}

// @public (undocumented)
export class OnAnimationEnd extends OnUUIDEvent<'onAnimationEnd'> {
    // (undocumented)
    readonly type: string;
}

// @public (undocumented)
export class OnBlur extends OnUUIDEvent<'onBlur'> {
    constructor(callback: (event: IEvents['onBlur']) => void);
    // (undocumented)
    readonly type: string;
}

// @public (undocumented)
export class OnChanged extends OnUUIDEvent<'onChange'> {
    constructor(callback: (event: IEvents['onChange']) => void);
    // (undocumented)
    readonly type: string;
}

// @public (undocumented)
export class OnClick extends OnUUIDEvent<'onClick'> {
    constructor(callback: (event: IEvents['onClick']) => void);
    // (undocumented)
    readonly type: string;
}

// @public (undocumented)
export class OnEnter extends OnUUIDEvent<'onEnter'> {
    constructor(callback: (event: IEvents['onEnter']) => void);
    // (undocumented)
    readonly type: string;
}

// @public (undocumented)
export class OnFocus extends OnUUIDEvent<'onFocus'> {
    constructor(callback: (event: IEvents['onFocus']) => void);
    // (undocumented)
    readonly type: string;
}

// @beta
export class OnGizmoEvent extends OnUUIDEvent<'gizmoEvent'> {
    // (undocumented)
    readonly type: string;
}

// @public (undocumented)
export class OnPointerDown extends OnUUIDEvent<'pointerDown'> {
    constructor(callback: (event: IEvents['pointerDown']) => void);
    // (undocumented)
    readonly type: string;
}

// @public (undocumented)
export class OnPointerUp extends OnUUIDEvent<'pointerUp'> {
    constructor(callback: (event: IEvents['pointerUp']) => void);
    // (undocumented)
    readonly type: string;
}

// @public (undocumented)
export class OnTextSubmit extends OnUUIDEvent<'onTextSubmit'> {
    constructor(callback: (event: IEvents['onTextSubmit']) => void);
    // (undocumented)
    readonly type: string;
}

// @public (undocumented)
export class OnUUIDEvent<T extends keyof IEvents> extends ObservableComponent {
    constructor(callback: (event: IEvents[T]) => void);
    // (undocumented)
    callback: (event: any) => void;
    // (undocumented)
    toJSON(): {
        uuid: string;
        type: string | undefined;
    };
    // (undocumented)
    readonly type: string | undefined;
    // (undocumented)
    readonly uuid: string;
    // (undocumented)
    static uuidEvent(target: ObservableComponent, propertyKey: string): void;
}

// @public
export enum Orientation {
    CCW = 1,
    CW = 0
}

// @public (undocumented)
export class ParentChanged {
    constructor(entity: IEntity, parent: IEntity | null);
    // (undocumented)
    entity: IEntity;
    // (undocumented)
    parent: IEntity | null;
}

// @public
export class Path2 {
    constructor(x: number, y: number);
    addArcTo(midX: number, midY: number, endX: number, endY: number, numberOfSegments?: number): Path2;
    addLineTo(x: number, y: number): Path2;
    close(): Path2;
    closed: boolean;
    getPointAtLengthPosition(normalizedLengthPosition: number): Vector2;
    getPoints(): Vector2[];
    length(): number;
    static StartingAt(x: number, y: number): Path2;
}

// @public
export class Path3D {
    constructor(
    path: Vector3[], firstNormal?: Nullable<Vector3>, raw?: boolean);
    getBinormals(): Vector3[];
    getCurve(): Vector3[];
    getDistances(): number[];
    getNormals(): Vector3[];
    getTangents(): Vector3[];
    path: Vector3[];
    update(path: Vector3[], firstNormal?: Nullable<Vector3>): Path3D;
}

// @public (undocumented)
export class PhysicsCast implements IPhysicsCast {
    // (undocumented)
    static ensureInstance(): any;
    // (undocumented)
    getRayFromCamera(distance: number): Ray;
    // (undocumented)
    getRayFromPositions(from: Vector3, to: Vector3): Ray;
    // (undocumented)
    handleRaycastHitAllResponse(response: RaycastResponse<RaycastHitEntities>): void;
    // (undocumented)
    handleRaycastHitFirstResponse(response: RaycastResponse<RaycastHitEntity>): void;
    // (undocumented)
    hitAll(ray: Ray, hitCallback: (event: RaycastHitEntities) => void): void;
    // (undocumented)
    hitAllAvatars(ray: Ray, hitCallback: (event: RaycastHitAvatars) => void): void;
    // (undocumented)
    hitFirst(ray: Ray, hitCallback: (event: RaycastHitEntity) => void): void;
    // (undocumented)
    hitFirstAvatar(ray: Ray, hitCallback: (event: RaycastHitAvatar) => void): void;
    // (undocumented)
    static readonly instance: PhysicsCast;
    }

// @public
export class Plane {
    constructor(a: number, b: number, c: number, d: number);
    // (undocumented)
    asArray(): number[];
    // (undocumented)
    clone(): Plane;
    copyFromPoints(point1: Vector3, point2: Vector3, point3: Vector3): Plane;
    d: number;
    dotCoordinate(point: Vector3): number;
    static FromArray(array: ArrayLike<number>): Plane;
    static FromPoints(point1: Vector3, point2: Vector3, point3: Vector3): Plane;
    static FromPositionAndNormal(origin: Vector3, normal: Vector3): Plane;
    // (undocumented)
    getClassName(): string;
    // (undocumented)
    getHashCode(): number;
    isFrontFacingTo(direction: Vector3, epsilon: number): boolean;
    normal: Vector3;
    normalize(): Plane;
    signedDistanceTo(point: Vector3): number;
    static SignedDistanceToPlaneFromPositionAndNormal(origin: Vector3, normal: Vector3, point: Vector3): number;
    transform(transformation: Matrix): Plane;
}

// @public (undocumented)
export class PlaneShape extends Shape {
    height: number;
    uvs?: number[];
    width: number;
}

// @public (undocumented)
export class PointerEvent<GlobalInputEventResult> {
    constructor(payload: GlobalInputEventResult);
    // (undocumented)
    readonly payload: GlobalInputEventResult;
}

// @public (undocumented)
export class PointerEventComponent {
    constructor(callback: (event: LocalActionButtonEvent) => void);
    // (undocumented)
    readonly callback: (event: LocalActionButtonEvent) => void;
}

// @public (undocumented)
export class PointerEventSystem implements ISystem {
    // (undocumented)
    activate(engine: Engine): void;
    // (undocumented)
    deactivate(): void;
}

// @public (undocumented)
export type ProfileForRenderer = {
    userId: string;
    name: string;
    description: string;
    email: string;
    avatar: AvatarForRenderer;
    inventory: WearableId[];
    snapshots: {
        face: string;
        body: string;
    };
    version: number;
    updatedAt: number;
    createdAt: number;
};

// @public
export class Quaternion {
    constructor(
    x?: number, 
    y?: number, 
    z?: number, 
    w?: number);
    static Angle(quat1: ReadOnlyQuaternion, quat2: ReadOnlyQuaternion): number;
    // (undocumented)
    angleAxis(degress: number, axis: Vector3): Quaternion;
    static AreClose(quat0: ReadOnlyQuaternion, quat1: ReadOnlyQuaternion): boolean;
    asArray(): number[];
    clone(): Quaternion;
    conjugate(): Quaternion;
    conjugateInPlace(): Quaternion;
    conjugateToRef(ref: Quaternion): Quaternion;
    copyFrom(other: ReadOnlyQuaternion): Quaternion;
    copyFromFloats(x: number, y: number, z: number, w: number): Quaternion;
    static Dot(left: ReadOnlyQuaternion, right: ReadOnlyQuaternion): number;
    equals(otherQuaternion: ReadOnlyQuaternion): boolean;
    static Euler(x: number, y: number, z: number): Quaternion;
    eulerAngles: Vector3;
    static FromArray(array: ArrayLike<number>, offset?: number): Quaternion;
    static FromEulerAnglesRef(x: number, y: number, z: number, result: Quaternion): void;
    static FromRotationMatrix(matrix: Matrix): Quaternion;
    fromRotationMatrix(matrix: Matrix): Quaternion;
    static FromRotationMatrixToRef(matrix: Matrix, result: Quaternion): void;
    static FromToRotation(from: Vector3, to: Vector3): Quaternion;
    getClassName(): string;
    getHashCode(): number;
    static Hermite(value1: ReadOnlyQuaternion, tangent1: ReadOnlyQuaternion, value2: ReadOnlyQuaternion, tangent2: ReadOnlyQuaternion, amount: number): Quaternion;
    static readonly Identity: Quaternion;
    static Inverse(q: Quaternion): Quaternion;
    static IsIdentity(quaternion: ReadOnlyQuaternion): boolean;
    readonly length: number;
    readonly lengthSquared: number;
    static LookRotation(forward: Vector3, up?: Vector3): Quaternion;
    multiply(q1: ReadOnlyQuaternion): Quaternion;
    multiplyInPlace(q1: ReadOnlyQuaternion): Quaternion;
    multiplyToRef(q1: ReadOnlyQuaternion, result: Quaternion): Quaternion;
    normalize(): Quaternion;
    readonly normalized: Quaternion;
    static RotateTowards(from: ReadOnlyQuaternion, to: Quaternion, maxDegreesDelta: number): Quaternion;
    static RotationAlphaBetaGamma(alpha: number, beta: number, gamma: number): Quaternion;
    static RotationAlphaBetaGammaToRef(alpha: number, beta: number, gamma: number, result: Quaternion): void;
    static RotationAxis(axis: Vector3, angle: number): Quaternion;
    static RotationAxisToRef(axis: Vector3, angle: number, result: Quaternion): Quaternion;
    static RotationQuaternionFromAxis(axis1: Vector3, axis2: Vector3, axis3: Vector3): Quaternion;
    static RotationQuaternionFromAxisToRef(axis1: Vector3, axis2: Vector3, axis3: Vector3, ref: Quaternion): void;
    static RotationYawPitchRoll(yaw: number, pitch: number, roll: number): Quaternion;
    static RotationYawPitchRollToRef(yaw: number, pitch: number, roll: number, result: Quaternion): void;
    scale(value: number): Quaternion;
    scaleAndAddToRef(scale: number, result: Quaternion): Quaternion;
    scaleInPlace(value: number): Quaternion;
    scaleToRef(scale: number, result: Quaternion): Quaternion;
    set(x: number, y: number, z: number, w: number): Quaternion;
    setEuler(x: number, y: number, z: number): Quaternion;
    setFromToRotation(from: Vector3, to: Vector3, up?: Vector3): void;
    static Slerp(left: ReadOnlyQuaternion, right: ReadOnlyQuaternion, amount: number): Quaternion;
    static SlerpToRef(left: ReadOnlyQuaternion, right: ReadOnlyQuaternion, amount: number, result: Quaternion): void;
    subtract(other: Quaternion): Quaternion;
    toRotationMatrix(result: Matrix): Quaternion;
    toString(): string;
    w: number;
    x: number;
    y: number;
    z: number;
    static Zero(): Quaternion;
}

// @public (undocumented)
export type QueryType = 'HitFirst' | 'HitAll' | 'HitFirstAvatar' | 'HitAllAvatars';

// @public
export const RAD2DEG: number;

// @public (undocumented)
export interface Ray {
    // (undocumented)
    direction: ReadOnlyVector3;
    // (undocumented)
    distance: number;
    // (undocumented)
    origin: ReadOnlyVector3;
}

// @public (undocumented)
export class RaycastEventSystem implements ISystem {
    // (undocumented)
    activate(engine: Engine): void;
    // (undocumented)
    deactivate(): void;
}

// @public (undocumented)
export interface RaycastHit {
    // (undocumented)
    didHit: boolean;
    // (undocumented)
    hitNormal: ReadOnlyVector3;
    // (undocumented)
    hitPoint: ReadOnlyVector3;
    // (undocumented)
    ray: Ray;
}

// @public (undocumented)
export interface RaycastHitAvatar extends RaycastHit {
    // (undocumented)
    avatar: BasicAvatarInfo;
}

// @public (undocumented)
export interface RaycastHitAvatars extends RaycastHit {
    // (undocumented)
    avatars: BasicAvatarInfo[];
}

// @public (undocumented)
export interface RaycastHitEntities extends RaycastHit {
    // (undocumented)
    entities: RaycastHitEntity[];
}

// @public (undocumented)
export interface RaycastHitEntity extends RaycastHit {
    // (undocumented)
    entity: HitEntityInfo;
}

// @public (undocumented)
export class RaycastResponse<T> {
    constructor(payload: {
        queryId: string;
        queryType: string;
        payload: T;
    });
    // (undocumented)
    readonly payload: {
        queryId: string;
        queryType: string;
        payload: T;
    };
}

// @public (undocumented)
export type ReadOnlyColor4 = {
    readonly r: number;
    readonly g: number;
    readonly b: number;
    readonly a: number;
};

// @public (undocumented)
export type ReadOnlyQuaternion = {
    readonly x: number;
    readonly y: number;
    readonly z: number;
    readonly w: number;
};

// @public (undocumented)
export type ReadOnlyVector2 = {
    readonly x: number;
    readonly y: number;
};

// @public (undocumented)
export type ReadOnlyVector3 = {
    readonly y: number;
    readonly x: number;
    readonly z: number;
};

// @public (undocumented)
export type ReadOnlyVector4 = {
    readonly y: number;
    readonly x: number;
    readonly z: number;
    readonly w: number;
};

// @public
export class Scalar {
    static Clamp(value: number, min?: number, max?: number): number;
    static DeltaAngle(current: number, target: number): number;
    static Denormalize(normalized: number, min: number, max: number): number;
    static Hermite(value1: number, tangent1: number, value2: number, tangent2: number, amount: number): number;
    static InverseLerp(a: number, b: number, value: number): number;
    static Lerp(start: number, end: number, amount: number): number;
    static LerpAngle(start: number, end: number, amount: number): number;
    static Log2(value: number): number;
    static MoveTowards(current: number, target: number, maxDelta: number): number;
    static MoveTowardsAngle(current: number, target: number, maxDelta: number): number;
    static Normalize(value: number, min: number, max: number): number;
    static NormalizeRadians(angle: number): number;
    static PercentToRange(percent: number, min: number, max: number): number;
    static PingPong(tx: number, length: number): number;
    static RandomRange(min: number, max: number): number;
    static RangeToPercent(num: number, min: number, max: number): number;
    static Repeat(value: number, length: number): number;
    static Sign(value: number): number;
    static SmoothStep(from: number, to: number, tx: number): number;
    static ToHex(i: number): string;
    static TwoPi: number;
    static WithinEpsilon(a: number, b: number, epsilon?: number): boolean;
}

// @public (undocumented)
export class Shape extends ObservableComponent {
    visible: boolean;
    withCollisions: boolean;
}

// @public
export class Size implements ISize {
    constructor(width: number, height: number);
    add(otherSize: Size): Size;
    clone(): Size;
    copyFrom(src: Size): void;
    copyFromFloats(width: number, height: number): Size;
    equals(other: Size): boolean;
    getClassName(): string;
    getHashCode(): number;
    height: number;
    static Lerp(start: Size, end: Size, amount: number): Size;
    multiplyByFloats(w: number, h: number): Size;
    set(width: number, height: number): Size;
    subtract(otherSize: Size): Size;
    readonly surface: number;
    toString(): string;
    width: number;
    static Zero(): Size;
}

// @public
export enum Space {
    BONE = 2,
    LOCAL = 0,
    WORLD = 1
}

// @public (undocumented)
export class SphereShape extends Shape {
}

// @public (undocumented)
export type TaskResult<T> = Promise<T> & {
    isComplete: boolean;
    didFail?: boolean;
    error?: Error;
    result?: T;
};

// @public (undocumented)
export class TextShape extends Shape {
    constructor(value?: string);
    // (undocumented)
    billboard: boolean;
    // (undocumented)
    color: Color3;
    // (undocumented)
    fontSize: number;
    // (undocumented)
    fontWeight: string;
    // (undocumented)
    height: number;
    // (undocumented)
    hTextAlign: string;
    // (undocumented)
    isPickable: boolean;
    // (undocumented)
    lineCount: number;
    // (undocumented)
    lineSpacing: string;
    // (undocumented)
    opacity: number;
    // (undocumented)
    outlineColor: Color3;
    // (undocumented)
    outlineWidth: number;
    // (undocumented)
    paddingBottom: number;
    // (undocumented)
    paddingLeft: number;
    // (undocumented)
    paddingRight: number;
    // (undocumented)
    paddingTop: number;
    // (undocumented)
    resizeToFit: boolean;
    // (undocumented)
    shadowBlur: number;
    // (undocumented)
    shadowColor: Color3;
    // (undocumented)
    shadowOffsetX: number;
    // (undocumented)
    shadowOffsetY: number;
    // (undocumented)
    textWrapping: boolean;
    // (undocumented)
    value: string;
    // (undocumented)
    vTextAlign: string;
    // (undocumented)
    width: number;
    // (undocumented)
    zIndex: number;
}

// @public (undocumented)
export class Texture extends ObservableComponent {
    constructor(src: string, opts?: Partial<Pick<Texture, 'samplingMode' | 'wrap' | 'hasAlpha'>>);
    readonly hasAlpha: boolean;
    readonly samplingMode: number;
    // (undocumented)
    readonly src: string;
    readonly wrap: number;
}

// @public
export const ToGammaSpace: number;

// @public
export const ToLinearSpace = 2.2;

// @public (undocumented)
export type TranformConstructorArgs = {
    position?: Vector3;
    rotation?: Quaternion;
    scale?: Vector3;
};

// @public (undocumented)
export class Transform extends ObservableComponent {
    constructor(args?: TranformConstructorArgs);
    readonly eulerAngles: Vector3;
    lookAt(target: Vector3, worldUp?: Vector3): this;
    // (undocumented)
    position: Vector3;
    rotate(axis: Vector3, angle: number): this;
    // (undocumented)
    rotation: Quaternion;
    // (undocumented)
    scale: Vector3;
    translate(vec: Vector3): this;
}

// @public (undocumented)
export enum TransparencyMode {
    // (undocumented)
    ALPHA_BLEND = 2,
    // (undocumented)
    ALPHA_TEST = 1,
    // (undocumented)
    ALPHA_TEST_AND_BLEND = 3,
    // (undocumented)
    AUTO = 4,
    // (undocumented)
    OPAQUE = 0
}

// @public (undocumented)
export class UIButton extends UIShape {
    // (undocumented)
    background: Color4;
    // (undocumented)
    color: Color4;
    // (undocumented)
    cornerRadius: number;
    // (undocumented)
    fontSize: number;
    // (undocumented)
    fontWeight: string;
    // (undocumented)
    paddingBottom: number;
    // (undocumented)
    paddingLeft: number;
    // (undocumented)
    paddingRight: number;
    // (undocumented)
    paddingTop: number;
    // (undocumented)
    shadowBlur: number;
    // (undocumented)
    shadowColor: Color4;
    // (undocumented)
    shadowOffsetX: number;
    // (undocumented)
    shadowOffsetY: number;
    // (undocumented)
    text: string;
    // (undocumented)
    thickness: number;
}

// @public (undocumented)
export class UICanvas extends UIShape {
    constructor();
}

// @public (undocumented)
export class UIContainerRect extends UIShape {
    // (undocumented)
    adaptHeight: boolean;
    // (undocumented)
    adaptWidth: boolean;
    // (undocumented)
    alignmentUsesSize: boolean;
    // (undocumented)
    color: Color4;
    // (undocumented)
    thickness: number;
}

// @public (undocumented)
export class UIContainerStack extends UIShape {
    // (undocumented)
    adaptHeight: boolean;
    // (undocumented)
    adaptWidth: boolean;
    // (undocumented)
    color: Color4;
    // (undocumented)
    spacing: Number;
    // (undocumented)
    stackOrientation: UIStackOrientation;
}

// @public (undocumented)
export class UIImage extends UIShape {
    constructor(parent: UIShape, source: Texture);
    // (undocumented)
    onClick: OnClick | null;
    // (undocumented)
    paddingBottom: number;
    // (undocumented)
    paddingLeft: number;
    // (undocumented)
    paddingRight: number;
    // (undocumented)
    paddingTop: number;
    // (undocumented)
    sizeInPixels: boolean;
    // (undocumented)
    source?: Texture;
    // (undocumented)
    sourceHeight: number;
    // (undocumented)
    sourceLeft: number;
    // (undocumented)
    sourceTop: number;
    // (undocumented)
    sourceWidth: number;
}

// @public (undocumented)
export class UIInputText extends UIShape {
    // (undocumented)
    autoStretchWidth: boolean;
    // (undocumented)
    background: Color4;
    // (undocumented)
    color: Color4;
    // (undocumented)
    focusedBackground: Color4;
    // (undocumented)
    fontSize: number;
    // (undocumented)
    fontWeight: string;
    // (undocumented)
    hTextAlign: string;
    // (undocumented)
    margin: number;
    // (undocumented)
    maxWidth: number;
    // (undocumented)
    onBlur: OnBlur | null;
    // (undocumented)
    onChanged: OnChanged | null;
    // (undocumented)
    onFocus: OnFocus | null;
    // (undocumented)
    onTextSubmit: OnTextSubmit | null;
    // (undocumented)
    outlineColor: Color4;
    // (undocumented)
    outlineWidth: number;
    // (undocumented)
    paddingBottom: number;
    // (undocumented)
    paddingLeft: number;
    // (undocumented)
    paddingRight: number;
    // (undocumented)
    paddingTop: number;
    // (undocumented)
    placeholder: string;
    // (undocumented)
    placeholderColor: Color4;
    // (undocumented)
    shadowBlur: number;
    // (undocumented)
    shadowColor: Color4;
    // (undocumented)
    shadowOffsetX: number;
    // (undocumented)
    shadowOffsetY: number;
    // (undocumented)
    textWrapping: boolean;
    // (undocumented)
    thickness: number;
    // (undocumented)
    value: string;
    // (undocumented)
    vTextAlign: string;
}

// @public (undocumented)
export class UIScrollRect extends UIShape {
    // (undocumented)
    backgroundColor: Color4;
    // (undocumented)
    borderColor: Color4;
    // (undocumented)
    isHorizontal: boolean;
    // (undocumented)
    isVertical: boolean;
    // (undocumented)
    onChanged: OnChanged | null;
    // (undocumented)
    paddingBottom: number;
    // (undocumented)
    paddingLeft: number;
    // (undocumented)
    paddingRight: number;
    // (undocumented)
    paddingTop: number;
    // (undocumented)
    valueX: number;
    // (undocumented)
    valueY: number;
}

// @public (undocumented)
export abstract class UIShape extends ObservableComponent {
    constructor(parent: UIShape | null);
    // (undocumented)
    hAlign: string;
    // (undocumented)
    height: string | number;
    // (undocumented)
    isPointerBlocker: boolean;
    name: string | null;
    // (undocumented)
    opacity: number;
    // (undocumented)
    readonly parent: UIShape | undefined;
    // (undocumented)
    positionX: string | number;
    // (undocumented)
    positionY: string | number;
    // (undocumented)
    vAlign: string;
    // (undocumented)
    visible: boolean;
    // (undocumented)
    width: string | number;
}

// @public (undocumented)
export enum UIStackOrientation {
    // (undocumented)
    HORIZONTAL = 1,
    // (undocumented)
    VERTICAL = 0
}

// @public (undocumented)
export class UIText extends UIShape {
    // (undocumented)
    adaptHeight: boolean;
    // (undocumented)
    adaptWidth: boolean;
    // (undocumented)
    color: Color4;
    // (undocumented)
    fontAutoSize: boolean;
    // (undocumented)
    fontSize: number;
    // (undocumented)
    fontWeight: string;
    // (undocumented)
    hTextAlign: string;
    // (undocumented)
    lineCount: number;
    // (undocumented)
    lineSpacing: number;
    // (undocumented)
    outlineColor: Color4;
    // (undocumented)
    outlineWidth: number;
    // (undocumented)
    paddingBottom: number;
    // (undocumented)
    paddingLeft: number;
    // (undocumented)
    paddingRight: number;
    // (undocumented)
    paddingTop: number;
    // (undocumented)
    shadowBlur: number;
    // (undocumented)
    shadowColor: Color4;
    // (undocumented)
    shadowOffsetX: number;
    // (undocumented)
    shadowOffsetY: number;
    // (undocumented)
    textWrapping: boolean;
    // (undocumented)
    value: string;
    // (undocumented)
    vTextAlign: string;
}

// @public (undocumented)
export class UIValue {
    constructor(value: string | number);
    // (undocumented)
    toString(): string;
    // (undocumented)
    type: UIValueType;
    // (undocumented)
    value: number;
}

// @public (undocumented)
export enum UIValueType {
    // (undocumented)
    PERCENT = 0,
    // (undocumented)
    PIXELS = 1
}

// @public (undocumented)
export class UUIDEvent<T = any> {
    constructor(uuid: string, payload: T);
    // (undocumented)
    readonly payload: T;
    // (undocumented)
    readonly uuid: string;
}

// @public (undocumented)
export class UUIDEventSystem implements ISystem {
    // (undocumented)
    activate(engine: Engine): void;
    // (undocumented)
    deactivate(): void;
    // (undocumented)
    handlerMap: {
        [uuid: string]: OnUUIDEvent<any>;
    };
    // (undocumented)
    onAddEntity(entity: IEntity): void;
    // (undocumented)
    onRemoveEntity(entity: IEntity): void;
}

// @public
export class Vector2 {
    constructor(
    x?: number, 
    y?: number);
    static Add(vector1: ReadOnlyVector2, vector2: ReadOnlyVector2): Vector2;
    add(otherVector: ReadOnlyVector2): Vector2;
    addInPlace(otherVector: ReadOnlyVector2): Vector2;
    addToRef(otherVector: ReadOnlyVector2, result: Vector2): Vector2;
    addVector3(otherVector: ReadOnlyVector2): Vector2;
    asArray(): number[];
    static CatmullRom(value1: ReadOnlyVector2, value2: ReadOnlyVector2, value3: ReadOnlyVector2, value4: ReadOnlyVector2, amount: number): Vector2;
    static Center(value1: ReadOnlyVector2, value2: ReadOnlyVector2): Vector2;
    static Clamp(value: ReadOnlyVector2, min: ReadOnlyVector2, max: ReadOnlyVector2): Vector2;
    clone(): Vector2;
    copyFrom(source: ReadOnlyVector2): Vector2;
    copyFromFloats(x: number, y: number): Vector2;
    static Distance(value1: Vector2, value2: Vector2): number;
    static DistanceOfPointFromSegment(p: Vector2, segA: Vector2, segB: Vector2): number;
    static DistanceSquared(value1: ReadOnlyVector2, value2: ReadOnlyVector2): number;
    divide(otherVector: ReadOnlyVector2): Vector2;
    divideInPlace(otherVector: ReadOnlyVector2): Vector2;
    divideToRef(otherVector: ReadOnlyVector2, result: Vector2): Vector2;
    static Dot(left: ReadOnlyVector2, right: ReadOnlyVector2): number;
    equals(otherVector: ReadOnlyVector2): boolean;
    equalsWithEpsilon(otherVector: ReadOnlyVector2, epsilon?: number): boolean;
    floor(): Vector2;
    fract(): Vector2;
    static FromArray(array: ArrayLike<number>, offset?: number): Vector2;
    static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Vector2): void;
    getClassName(): string;
    getHashCode(): number;
    static Hermite(value1: ReadOnlyVector2, tangent1: ReadOnlyVector2, value2: ReadOnlyVector2, tangent2: ReadOnlyVector2, amount: number): Vector2;
    length(): number;
    lengthSquared(): number;
    static Lerp(start: ReadOnlyVector2, end: ReadOnlyVector2, amount: number): Vector2;
    static Maximize(left: ReadOnlyVector2, right: ReadOnlyVector2): Vector2;
    static Minimize(left: ReadOnlyVector2, right: ReadOnlyVector2): Vector2;
    multiply(otherVector: ReadOnlyVector2): Vector2;
    multiplyByFloats(x: number, y: number): Vector2;
    multiplyInPlace(otherVector: ReadOnlyVector2): Vector2;
    multiplyToRef(otherVector: ReadOnlyVector2, result: Vector2): Vector2;
    negate(): Vector2;
    static Normalize(vector: ReadOnlyVector2): Vector2;
    normalize(): Vector2;
    static One(): Vector2;
    static PointInTriangle(p: ReadOnlyVector2, p0: ReadOnlyVector2, p1: ReadOnlyVector2, p2: ReadOnlyVector2): boolean;
    scale(scale: number): Vector2;
    scaleAndAddToRef(scale: number, result: Vector2): Vector2;
    scaleInPlace(scale: number): Vector2;
    scaleToRef(scale: number, result: Vector2): Vector2;
    set(x: number, y: number): Vector2;
    subtract(otherVector: ReadOnlyVector2): Vector2;
    subtractInPlace(otherVector: ReadOnlyVector2): Vector2;
    subtractToRef(otherVector: ReadOnlyVector2, result: Vector2): Vector2;
    toArray(array: FloatArray, index?: number): Vector2;
    toString(): string;
    static Transform(vector: Vector2, transformation: Matrix): Vector2;
    static TransformToRef(vector: ReadOnlyVector2, transformation: Matrix, result: Vector2): void;
    x: number;
    y: number;
    static Zero(): Vector2;
}

// @public
export class Vector3 {
    constructor(
    x?: number, 
    y?: number, 
    z?: number);
    static Add(vector1: ReadOnlyVector3, vector2: ReadOnlyVector3): Vector3;
    add(otherVector: ReadOnlyVector3): Vector3;
    addInPlace(otherVector: ReadOnlyVector3): Vector3;
    addInPlaceFromFloats(x: number, y: number, z: number): Vector3;
    addToRef(otherVector: ReadOnlyVector3, result: Vector3): Vector3;
    applyMatrix4(matrix: Matrix): void;
    applyMatrix4ToRef(matrix: Matrix, result: Vector3): Vector3;
    asArray(): number[];
    static Backward(): Vector3;
    static CatmullRom(value1: ReadOnlyVector3, value2: ReadOnlyVector3, value3: ReadOnlyVector3, value4: ReadOnlyVector3, amount: number): Vector3;
    static Center(value1: ReadOnlyVector3, value2: ReadOnlyVector3): Vector3;
    static Clamp(value: ReadOnlyVector3, min: ReadOnlyVector3, max: ReadOnlyVector3): Vector3;
    static ClampToRef(value: ReadOnlyVector3, min: ReadOnlyVector3, max: ReadOnlyVector3, result: Vector3): void;
    clone(): Vector3;
    copyFrom(source: ReadOnlyVector3): Vector3;
    copyFromFloats(x: number, y: number, z: number): Vector3;
    static Cross(left: ReadOnlyVector3, right: ReadOnlyVector3): Vector3;
    static CrossToRef(left: ReadOnlyVector3, right: ReadOnlyVector3, result: Vector3): void;
    static Distance(value1: ReadOnlyVector3, value2: ReadOnlyVector3): number;
    static DistanceSquared(value1: ReadOnlyVector3, value2: ReadOnlyVector3): number;
    divide(otherVector: ReadOnlyVector3): Vector3;
    divideInPlace(otherVector: ReadOnlyVector3): Vector3;
    divideToRef(otherVector: ReadOnlyVector3, result: Vector3): Vector3;
    static Dot(left: ReadOnlyVector3, right: ReadOnlyVector3): number;
    static Down(): Vector3;
    equals(otherVector: ReadOnlyVector3): boolean;
    equalsToFloats(x: number, y: number, z: number): boolean;
    equalsWithEpsilon(otherVector: ReadOnlyVector3, epsilon?: number): boolean;
    floor(): Vector3;
    static Forward(): Vector3;
    fract(): Vector3;
    static FromArray(array: ArrayLike<number>, offset?: number): Vector3;
    static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Vector3): void;
    static FromFloatArray(array: FloatArray, offset?: number): Vector3;
    static FromFloatArrayToRef(array: FloatArray, offset: number, result: Vector3): void;
    static FromFloatsToRef(x: number, y: number, z: number, result: Vector3): void;
    static GetAngleBetweenVectors(vector0: Vector3, vector1: Vector3, normal: ReadOnlyVector3): number;
    getClassName(): string;
    static GetClipFactor(vector0: ReadOnlyVector3, vector1: ReadOnlyVector3, axis: ReadOnlyVector3, size: number): number;
    getHashCode(): number;
    static Hermite(value1: ReadOnlyVector3, tangent1: ReadOnlyVector3, value2: ReadOnlyVector3, tangent2: ReadOnlyVector3, amount: number): Vector3;
    readonly isNonUniform: boolean;
    static Left(): Vector3;
    length(): number;
    lengthSquared(): number;
    static Lerp(start: ReadOnlyVector3, end: ReadOnlyVector3, amount: number): Vector3;
    static LerpToRef(start: ReadOnlyVector3, end: ReadOnlyVector3, amount: number, result: Vector3): void;
    static Maximize(left: Vector3, right: Vector3): Vector3;
    maximizeInPlace(other: ReadOnlyVector3): Vector3;
    maximizeInPlaceFromFloats(x: number, y: number, z: number): Vector3;
    static Minimize(left: ReadOnlyVector3, right: ReadOnlyVector3): Vector3;
    minimizeInPlace(other: ReadOnlyVector3): Vector3;
    minimizeInPlaceFromFloats(x: number, y: number, z: number): Vector3;
    multiply(otherVector: ReadOnlyVector3): Vector3;
    multiplyByFloats(x: number, y: number, z: number): Vector3;
    multiplyInPlace(otherVector: ReadOnlyVector3): Vector3;
    multiplyToRef(otherVector: ReadOnlyVector3, result: Vector3): Vector3;
    negate(): Vector3;
    static Normalize(vector: Vector3): Vector3;
    normalize(): Vector3;
    normalizeFromLength(len: number): Vector3;
    normalizeToNew(): Vector3;
    static NormalizeToRef(vector: Vector3, result: Vector3): void;
    normalizeToRef(reference: Vector3): Vector3;
    static One(): Vector3;
    static Right(): Vector3;
    rotate(q: Quaternion): Vector3;
    rotateToRef(q: Quaternion, result: Vector3): Vector3;
    static RotationFromAxis(axis1: Vector3, axis2: Vector3, axis3: Vector3): Vector3;
    static RotationFromAxisToRef(axis1: Vector3, axis2: Vector3, axis3: Vector3, ref: Vector3): void;
    scale(scale: number): Vector3;
    scaleAndAddToRef(scale: number, result: Vector3): Vector3;
    scaleInPlace(scale: number): Vector3;
    scaleToRef(scale: number, result: Vector3): Vector3;
    set(x: number, y: number, z: number): Vector3;
    setAll(v: number): Vector3;
    subtract(otherVector: ReadOnlyVector3): Vector3;
    subtractFromFloats(x: number, y: number, z: number): Vector3;
    subtractFromFloatsToRef(x: number, y: number, z: number, result: Vector3): Vector3;
    subtractInPlace(otherVector: ReadOnlyVector3): Vector3;
    subtractToRef(otherVector: ReadOnlyVector3, result: Vector3): Vector3;
    toArray(array: FloatArray, index?: number): Vector3;
    toQuaternion(): Quaternion;
    toString(): string;
    static TransformCoordinates(vector: ReadOnlyVector3, transformation: Matrix): Vector3;
    static TransformCoordinatesFromFloatsToRef(x: number, y: number, z: number, transformation: Readonly<Matrix>, result: Vector3): void;
    static TransformCoordinatesToRef(vector: ReadOnlyVector3, transformation: Readonly<Matrix>, result: Vector3): void;
    static TransformNormal(vector: ReadOnlyVector3, transformation: Matrix): Vector3;
    static TransformNormalFromFloatsToRef(x: number, y: number, z: number, transformation: Readonly<Matrix>, result: Vector3): void;
    static TransformNormalToRef(vector: ReadOnlyVector3, transformation: Readonly<Matrix>, result: Vector3): void;
    static Up(): Vector3;
    x: number;
    y: number;
    z: number;
    static Zero(): Vector3;
}

// @public
export class Vector4 {
    constructor(
    x: number, 
    y: number, 
    z: number, 
    w: number);
    static Add(vector1: ReadOnlyVector4, vector2: ReadOnlyVector4): Vector4;
    add(otherVector: ReadOnlyVector4): Vector4;
    addInPlace(otherVector: ReadOnlyVector4): Vector4;
    addToRef(otherVector: ReadOnlyVector4, result: Vector4): Vector4;
    asArray(): number[];
    static Center(value1: ReadOnlyVector4, value2: ReadOnlyVector4): Vector4;
    clone(): Vector4;
    copyFrom(source: ReadOnlyVector4): Vector4;
    copyFromFloats(x: number, y: number, z: number, w: number): Vector4;
    static Distance(value1: ReadOnlyVector4, value2: ReadOnlyVector4): number;
    static DistanceSquared(value1: ReadOnlyVector4, value2: ReadOnlyVector4): number;
    divide(otherVector: ReadOnlyVector4): Vector4;
    divideInPlace(otherVector: ReadOnlyVector4): Vector4;
    divideToRef(otherVector: ReadOnlyVector4, result: Vector4): Vector4;
    equals(otherVector: ReadOnlyVector4): boolean;
    equalsToFloats(x: number, y: number, z: number, w: number): boolean;
    equalsWithEpsilon(otherVector: ReadOnlyVector4, epsilon?: number): boolean;
    floor(): Vector4;
    fract(): Vector4;
    static FromArray(array: ArrayLike<number>, offset?: number): Vector4;
    static FromArrayToRef(array: ArrayLike<number>, offset: number, result: Vector4): void;
    static FromFloatArrayToRef(array: FloatArray, offset: number, result: Vector4): void;
    static FromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): void;
    getClassName(): string;
    getHashCode(): number;
    length(): number;
    lengthSquared(): number;
    static Maximize(left: ReadOnlyVector4, right: ReadOnlyVector4): Vector4;
    maximizeInPlace(other: ReadOnlyVector4): Vector4;
    static Minimize(left: ReadOnlyVector4, right: ReadOnlyVector4): Vector4;
    minimizeInPlace(other: ReadOnlyVector4): Vector4;
    multiply(otherVector: ReadOnlyVector4): Vector4;
    multiplyByFloats(x: number, y: number, z: number, w: number): Vector4;
    multiplyInPlace(otherVector: ReadOnlyVector4): Vector4;
    multiplyToRef(otherVector: ReadOnlyVector4, result: Vector4): Vector4;
    negate(): Vector4;
    static Normalize(vector: ReadOnlyVector4): Vector4;
    normalize(): Vector4;
    static NormalizeToRef(vector: ReadOnlyVector4, result: Vector4): void;
    static One(): Vector4;
    scale(scale: number): Vector4;
    scaleAndAddToRef(scale: number, result: Vector4): Vector4;
    scaleInPlace(scale: number): Vector4;
    scaleToRef(scale: number, result: Vector4): Vector4;
    set(x: number, y: number, z: number, w: number): Vector4;
    setAll(v: number): Vector4;
    subtract(otherVector: ReadOnlyVector4): Vector4;
    subtractFromFloats(x: number, y: number, z: number, w: number): Vector4;
    subtractFromFloatsToRef(x: number, y: number, z: number, w: number, result: Vector4): Vector4;
    subtractInPlace(otherVector: ReadOnlyVector4): Vector4;
    subtractToRef(otherVector: ReadOnlyVector4, result: Vector4): Vector4;
    toArray(array: FloatArray, index?: number): Vector4;
    toString(): string;
    toVector3(): Vector3;
    static TransformNormal(vector: ReadOnlyVector4, transformation: Matrix): Vector4;
    static TransformNormalFromFloatsToRef(x: number, y: number, z: number, w: number, transformation: Matrix, result: Vector4): void;
    static TransformNormalToRef(vector: ReadOnlyVector4, transformation: Matrix, result: Vector4): void;
    w: number;
    x: number;
    y: number;
    z: number;
    static Zero(): Vector4;
}

// @public (undocumented)
export type Wearable = {
    id: WearableId;
    type: 'wearable';
    category: string;
    baseUrl: string;
    tags: string[];
    representations: BodyShapeRespresentation[];
};

// @public (undocumented)
export type WearableId = string;


// (No @packageDocumentation comment for this package)

```
